<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `SIG` struct in crate `trust_dns`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, SIG">

    <title>trust_dns::rr::rdata::sig::SIG - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../../../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='../../../index.html'>trust_dns</a>::<wbr><a href='../../index.html'>rr</a>::<wbr><a href='../index.html'>rdata</a>::<wbr><a href='index.html'>sig</a></p><script>window.sidebarCurrent = {name: 'SIG', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../../../index.html'>trust_dns</a>::<wbr><a href='../../index.html'>rr</a>::<wbr><a href='../index.html'>rdata</a>::<wbr><a href='index.html'>sig</a>::<wbr><a class='struct' href=''>SIG</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-2880' class='srclink' href='../../../../src/trust_dns/src/rr/rdata/sig.rs.html#183-185' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct SIG {
    // some fields omitted
}</pre><div class='docblock'><p><a href="https://tools.ietf.org/html/rfc2535#section-4">RFC 2535, Domain Name System Security Extensions, March 1999</a></p>

<p>NOTE: RFC 2535 was obsoleted with 4034+, with the exception of the
 usage for UPDATE, which is what this implementation is for.</p>

<pre><code class="language-text">4.1 SIG RDATA Format

 The RDATA portion of a SIG RR is as shown below.  The integrity of
 the RDATA information is protected by the signature field.

 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        type covered           |  algorithm    |     labels    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         original TTL                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      signature expiration                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      signature inception                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            key  tag           |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+         signer&#39;s name         +
|                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-/
/                                                               /
/                            signature                          /
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</code></pre>

<p><a href="https://tools.ietf.org/html/rfc2931">RFC 2931, DNS Request and Transaction Signatures, September 2000</a></p>

<p>NOTE: 2931 updates SIG0 to clarify certain particulars...</p>

<pre><code class="language-text">RFC 2931                       DNS SIG(0)                 September 2000

3. The SIG(0) Resource Record

   The structure of and type number of SIG resource records (RRs) is
   given in [RFC 2535] Section 4.1.  However all of Section 4.1.8.1 and
   the parts of Sections 4.2 and 4.3 related to SIG(0) should be
   considered replaced by the material below.  Any conflict between [RFC
   2535] and this document concerning SIG(0) RRs should be resolved in
   favor of this document.

   For all transaction SIG(0)s, the signer field MUST be a name of the
   originating host and there MUST be a KEY RR at that name with the
   public key corresponding to the private key used to calculate the
   signature.  (The host domain name used may be the inverse IP address
   mapping name for an IP address of the host if the relevant KEY is
   stored there.)

   For all SIG(0) RRs, the owner name, class, TTL, and original TTL, are
   meaningless.  The TTL fields SHOULD be zero and the CLASS field
   SHOULD be ANY.  To conserve space, the owner name SHOULD be root (a
   single zero octet).  When SIG(0) authentication on a response is
   desired, that SIG RR MUST be considered the highest priority of any
   additional information for inclusion in the response. If the SIG(0)
   RR cannot be added without causing the message to be truncated, the
   server MUST alter the response so that a SIG(0) can be included.
   This response consists of only the question and a SIG(0) record, and
   has the TC bit set and RCODE 0 (NOERROR).  The client should at this
   point retry the request using TCP.

3.1 Calculating Request and Transaction SIGs

   A DNS request may be optionally signed by including one SIG(0)s at
   the end of the query additional information section.  Such a SIG is
   identified by having a &quot;type covered&quot; field of zero. It signs the
   preceding DNS request message including DNS header but not including
   the UDP/IP header and before the request RR counts have been adjusted
   for the inclusions of the request SIG(0).

   It is calculated by using a &quot;data&quot; (see [RFC 2535], Section 4.1.8) of
   (1) the SIG&#39;s RDATA section entirely omitting (not just zeroing) the
   signature subfield itself, (2) the DNS query messages, including DNS
   header, but not the UDP/IP header and before the reply RR counts have
   been adjusted for the inclusion of the SIG(0).  That is

      data = RDATA | request - SIG(0)

   where &quot;|&quot; is concatenation and RDATA is the RDATA of the SIG(0) being
   calculated less the signature itself.

   Similarly, a SIG(0) can be used to secure a response and the request
   that produced it.  Such transaction signatures are calculated by
   using a &quot;data&quot; of (1) the SIG&#39;s RDATA section omitting the signature
   itself, (2) the entire DNS query message that produced this response,
   including the query&#39;s DNS header but not its UDP/IP header, and (3)
   the entire DNS response message, including DNS header but not the
   UDP/IP header and before the response RR counts have been adjusted
   for the inclusion of the SIG(0).

   That is

      data = RDATA | full query | response - SIG(0)

   where &quot;|&quot; is concatenation and RDATA is the RDATA of the SIG(0) being
   calculated less the signature itself.

   Verification of a response SIG(0) (which is signed by the server host
   key, not the zone key) by the requesting resolver shows that the
   query and response were not tampered with in transit, that the
   response corresponds to the intended query, and that the response
   comes from the queried server.

   In the case of a DNS message via TCP, a SIG(0) on the first data
   packet is calculated with &quot;data&quot; as above and for each subsequent
   packet, it is calculated as follows:

      data = RDATA | DNS payload - SIG(0) | previous packet

   where &quot;|&quot; is concatenations, RDATA is as above, and previous packet
   is the previous DNS payload including DNS header and the SIG(0) but
   not the TCP/IP header.  Support of SIG(0) for TCP is OPTIONAL.  As an
   alternative, TSIG may be used after, if necessary, setting up a key
   with TKEY [RFC 2930].

   Except where needed to authenticate an update, TKEY, or similar
   privileged request, servers are not required to check a request
   SIG(0).

   Note: requests and responses can either have a single TSIG or one
   SIG(0) but not both a TSIG and a SIG(0).

3.2 Processing Responses and SIG(0) RRs

   If a SIG RR is at the end of the additional information section of a
   response and has a type covered of zero, it is a transaction
   signature covering the response and the query that produced the
   response.  For TKEY responses, it MUST be checked and the message
   rejected if the checks fail unless otherwise specified for the TKEY
   mode in use.  For all other responses, it MAY be checked and the
   message rejected if the checks fail.

   If a response&#39;s SIG(0) check succeed, such a transaction
   authentication SIG does NOT directly authenticate the validity any
   data-RRs in the message.  However, it authenticates that they were
   sent by the queried server and have not been diddled.  (Only a proper
   SIG(0) RR signed by the zone or a key tracing its authority to the
   zone or to static resolver configuration can directly authenticate

   data-RRs, depending on resolver policy.) If a resolver or server does
   not implement transaction and/or request SIGs, it MUST ignore them
   without error where they are optional and treat them as failing where
   they are required.

3.3 SIG(0) Lifetime and Expiration

   The inception and expiration times in SIG(0)s are for the purpose of
   resisting replay attacks.  They should be set to form a time bracket
   such that messages outside that bracket can be ignored.  In IP
   networks, this time bracket should not normally extend further than 5
   minutes into the past and 5 minutes into the future.
</code></pre>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl <a class='struct' href='../../../../trust_dns/rr/rdata/sig/struct.SIG.html' title='trust_dns::rr::rdata::sig::SIG'>SIG</a></code></h3><div class='impl-items'><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>(type_covered: <a class='enum' href='../../../../trust_dns/rr/record_type/enum.RecordType.html' title='trust_dns::rr::record_type::RecordType'>RecordType</a>, algorithm: <a class='enum' href='../../../../trust_dns/rr/dnssec/enum.Algorithm.html' title='trust_dns::rr::dnssec::Algorithm'>Algorithm</a>, num_labels: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a>, original_ttl: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>, sig_expiration: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>, sig_inception: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>, key_tag: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u16.html'>u16</a>, signer_name: <a class='struct' href='../../../../trust_dns/rr/domain/struct.Name.html' title='trust_dns::rr::domain::Name'>Name</a>, sig: <a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a>&gt;) -&gt; <a class='struct' href='../../../../trust_dns/rr/rdata/sig/struct.SIG.html' title='trust_dns::rr::rdata::sig::SIG'>SIG</a></code></h4>
<div class='docblock'><p>Creates a new SIG record data, used for both RRSIG and SIG(0) records.</p>

<h1 id='arguments' class='section-header'><a href='#arguments'>Arguments</a></h1>
<ul>
<li><code>type_covered</code> - The <code>RecordType</code> which this signature covers, should be NULL for SIG(0).</li>
<li><code>algorithm</code> - The <code>Algorithm</code> used to generat the the <code>signature</code>.</li>
<li><code>num_labels</code> - The number of labels in the name, should be less 1 for *.name labels,
             see <code>Name::num_labels()</code>.</li>
<li><code>original_ttl</code> - The TTL for the RRSet stored in the zone, should be 0 for SIG(0).</li>
<li><code>sig_expiration</code> - Timestamp at which this signature is no longer valid, very important to
                 keep this low, &lt; +5 minutes to limit replay attacks.</li>
<li><code>sig_inception</code> - Timestamp when this signature was generated.</li>
<li><code>key_tag</code> - See the key_tag generation in <code>rr::dnssec::Signer::key_tag()</code>.</li>
<li><code>signer_name</code> - Domain name of the server which was used to generate the signature.</li>
<li><code>sig</code> - signature stored in this record.</li>
</ul>

<h1 id='return-value' class='section-header'><a href='#return-value'>Return value</a></h1>
<p>The new SIG record data.</p>
</div><h4 id='method.get_type_covered' class='method'><code>fn <a href='#method.get_type_covered' class='fnname'>get_type_covered</a>(&amp;self) -&gt; <a class='enum' href='../../../../trust_dns/rr/record_type/enum.RecordType.html' title='trust_dns::rr::record_type::RecordType'>RecordType</a></code></h4>
<div class='docblock'><p><a href="https://tools.ietf.org/html/rfc2535#section-4.1.1">RFC 2535, Domain Name System Security Extensions, March 1999</a></p>

<pre><code class="language-text">4.1.1 Type Covered Field

 The &quot;type covered&quot; is the type of the other RRs covered by this SIG.
</code></pre>
</div><h4 id='method.get_algorithm' class='method'><code>fn <a href='#method.get_algorithm' class='fnname'>get_algorithm</a>(&amp;self) -&gt; <a class='enum' href='../../../../trust_dns/rr/dnssec/enum.Algorithm.html' title='trust_dns::rr::dnssec::Algorithm'>Algorithm</a></code></h4>
<div class='docblock'><p><a href="https://tools.ietf.org/html/rfc2535#section-4.1.2">RFC 2535, Domain Name System Security Extensions, March 1999</a></p>

<pre><code class="language-text">4.1.2 Algorithm Number Field

 This octet is as described in section 3.2.
</code></pre>
</div><h4 id='method.get_num_labels' class='method'><code>fn <a href='#method.get_num_labels' class='fnname'>get_num_labels</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a></code></h4>
<div class='docblock'><p><a href="https://tools.ietf.org/html/rfc2535#section-4.1.3">RFC 2535, Domain Name System Security Extensions, March 1999</a></p>

<pre><code class="language-text">4.1.3 Labels Field

 The &quot;labels&quot; octet is an unsigned count of how many labels there are
 in the original SIG RR owner name not counting the null label for
 root and not counting any initial &quot;*&quot; for a wildcard.  If a secured
 retrieval is the result of wild card substitution, it is necessary
 for the resolver to use the original form of the name in verifying
 the digital signature.  This field makes it easy to determine the
 original form.

 If, on retrieval, the RR appears to have a longer name than indicated
 by &quot;labels&quot;, the resolver can tell it is the result of wildcard
 substitution.  If the RR owner name appears to be shorter than the
 labels count, the SIG RR must be considered corrupt and ignored.  The
 maximum number of labels allowed in the current DNS is 127 but the
 entire octet is reserved and would be required should DNS names ever
 be expanded to 255 labels.  The following table gives some examples.
 The value of &quot;labels&quot; is at the top, the retrieved owner name on the
 left, and the table entry is the name to use in signature
 verification except that &quot;bad&quot; means the RR is corrupt.

 labels= |  0  |   1  |    2   |      3   |      4   |
 --------+-----+------+--------+----------+----------+
        .|   . | bad  |  bad   |    bad   |    bad   |
       d.|  *. |   d. |  bad   |    bad   |    bad   |
     c.d.|  *. | *.d. |   c.d. |    bad   |    bad   |
   b.c.d.|  *. | *.d. | *.c.d. |   b.c.d. |    bad   |
 a.b.c.d.|  *. | *.d. | *.c.d. | *.b.c.d. | a.b.c.d. |
</code></pre>
</div><h4 id='method.get_original_ttl' class='method'><code>fn <a href='#method.get_original_ttl' class='fnname'>get_original_ttl</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a></code></h4>
<div class='docblock'><p><a href="https://tools.ietf.org/html/rfc2535#section-4.1.4">RFC 2535, Domain Name System Security Extensions, March 1999</a></p>

<pre><code class="language-text">4.1.4 Original TTL Field

 The &quot;original TTL&quot; field is included in the RDATA portion to avoid
 (1) authentication problems that caching servers would otherwise
 cause by decrementing the real TTL field and (2) security problems
 that unscrupulous servers could otherwise cause by manipulating the
 real TTL field.  This original TTL is protected by the signature
 while the current TTL field is not.

 NOTE:  The &quot;original TTL&quot; must be restored into the covered RRs when
 the signature is verified (see Section 8).  This generaly implies
 that all RRs for a particular type, name, and class, that is, all the
 RRs in any particular RRset, must have the same TTL to start with.
</code></pre>
</div><h4 id='method.get_sig_expiration' class='method'><code>fn <a href='#method.get_sig_expiration' class='fnname'>get_sig_expiration</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a></code></h4>
<div class='docblock'><p><a href="https://tools.ietf.org/html/rfc2535#section-4.1.5">RFC 2535, Domain Name System Security Extensions, March 1999</a></p>

<pre><code class="language-text">4.1.5 Signature Expiration and Inception Fields

 The SIG is valid from the &quot;signature inception&quot; time until the
 &quot;signature expiration&quot; time.  Both are unsigned numbers of seconds
 since the start of 1 January 1970, GMT, ignoring leap seconds.  (See
 also Section 4.4.)  Ring arithmetic is used as for DNS SOA serial
 numbers [RFC 1982] which means that these times can never be more
 than about 68 years in the past or the future.  This means that these
 times are ambiguous modulo ~136.09 years.  However there is no
 security flaw because keys are required to be changed to new random
 keys by [RFC 2541] at least every five years.  This means that the
 probability that the same key is in use N*136.09 years later should
 be the same as the probability that a random guess will work.

 A SIG RR may have an expiration time numerically less than the
 inception time if the expiration time is near the 32 bit wrap around
 point and/or the signature is long lived.

 (To prevent misordering of network requests to update a zone
 dynamically, monotonically increasing &quot;signature inception&quot; times may
 be necessary.)

 A secure zone must be considered changed for SOA serial number
 purposes not only when its data is updated but also when new SIG RRs
 are inserted (ie, the zone or any part of it is re-signed).
</code></pre>
</div><h4 id='method.get_sig_inception' class='method'><code>fn <a href='#method.get_sig_inception' class='fnname'>get_sig_inception</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a></code></h4>
<div class='docblock'><p>see <code>get_sig_expiration</code></p>
</div><h4 id='method.get_key_tag' class='method'><code>fn <a href='#method.get_key_tag' class='fnname'>get_key_tag</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u16.html'>u16</a></code></h4>
<div class='docblock'><p><a href="https://tools.ietf.org/html/rfc2535#section-4.1.6">RFC 2535, Domain Name System Security Extensions, March 1999</a></p>

<pre><code class="language-text">4.1.6 Key Tag Field

 The &quot;key Tag&quot; is a two octet quantity that is used to efficiently
 select between multiple keys which may be applicable and thus check
 that a public key about to be used for the computationally expensive
 effort to check the signature is possibly valid.  For algorithm 1
 (MD5/RSA) as defined in [RFC 2537], it is the next to the bottom two
 octets of the public key modulus needed to decode the signature
 field.  That is to say, the most significant 16 of the least
 significant 24 bits of the modulus in network (big endian) order. For
 all other algorithms, including private algorithms, it is calculated
 as a simple checksum of the KEY RR as described in Appendix C.
</code></pre>
</div><h4 id='method.get_signer_name' class='method'><code>fn <a href='#method.get_signer_name' class='fnname'>get_signer_name</a>(&amp;self) -&gt; &amp;<a class='struct' href='../../../../trust_dns/rr/domain/struct.Name.html' title='trust_dns::rr::domain::Name'>Name</a></code></h4>
<div class='docblock'><p><a href="https://tools.ietf.org/html/rfc2535#section-4.1.7">RFC 2535, Domain Name System Security Extensions, March 1999</a></p>

<pre><code class="language-text">4.1.7 Signer&#39;s Name Field

 The &quot;signer&#39;s name&quot; field is the domain name of the signer generating
 the SIG RR.  This is the owner name of the public KEY RR that can be
 used to verify the signature.  It is frequently the zone which
 contained the RRset being authenticated.  Which signers should be
 authorized to sign what is a significant resolver policy question as
 discussed in Section 6. The signer&#39;s name may be compressed with
 standard DNS name compression when being transmitted over the
 network.
</code></pre>
</div><h4 id='method.get_sig' class='method'><code>fn <a href='#method.get_sig' class='fnname'>get_sig</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a></code></h4>
<div class='docblock'><p><a href="https://tools.ietf.org/html/rfc2535#section-4.1.8">RFC 2535, Domain Name System Security Extensions, March 1999</a></p>

<pre><code class="language-text">4.1.8 Signature Field

 The actual signature portion of the SIG RR binds the other RDATA
 fields to the RRset of the &quot;type covered&quot; RRs with that owner name
 and class.  This covered RRset is thereby authenticated.  To
 accomplish this, a data sequence is constructed as follows:

 data = RDATA | RR(s)...

 where &quot;|&quot; is concatenation,

 RDATA is the wire format of all the RDATA fields in the SIG RR itself
 (including the canonical form of the signer&#39;s name) before but not
 including the signature, and

 RR(s) is the RRset of the RR(s) of the type covered with the same
 owner name and class as the SIG RR in canonical form and order as
 defined in Section 8.

 How this data sequence is processed into the signature is algorithm
 dependent.  These algorithm dependent formats and procedures are
 described in separate documents (Section 3.2).

 SIGs SHOULD NOT be included in a zone for any &quot;meta-type&quot; such as
 ANY, AXFR, etc. (but see section 5.6.2 with regard to IXFR).
</code></pre>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 id='derived_implementations'>Derived Implementations </h3><h3 class='impl'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a> for <a class='struct' href='../../../../trust_dns/rr/rdata/sig/struct.SIG.html' title='trust_dns::rr::rdata::sig::SIG'>SIG</a></code></h3><div class='impl-items'><h4 id='method.clone' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class='struct' href='../../../../trust_dns/rr/rdata/sig/struct.SIG.html' title='trust_dns::rr::rdata::sig::SIG'>SIG</a></code></h4>
<h4 id='method.clone_from' class='method'><span class="since">1.0.0</span><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> for <a class='struct' href='../../../../trust_dns/rr/rdata/sig/struct.SIG.html' title='trust_dns::rr::rdata::sig::SIG'>SIG</a></code></h3><div class='impl-items'><h4 id='method.hash' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash' class='fnname'>hash</a>&lt;__H: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html' title='core::hash::Hasher'>Hasher</a>&gt;(&amp;self, __arg_0: &amp;mut __H)</code></h4>
<h4 id='method.hash_slice' class='method'><span class="since">1.3.0</span><code>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice' class='fnname'>hash_slice</a>&lt;H&gt;(data: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[Self]</a>, state: &amp;mut H) <span class='where'>where H: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html' title='core::hash::Hasher'>Hasher</a></span></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a> for <a class='struct' href='../../../../trust_dns/rr/rdata/sig/struct.SIG.html' title='trust_dns::rr::rdata::sig::SIG'>SIG</a></code></h3><div class='impl-items'></div><h3 class='impl'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html' title='core::cmp::PartialEq'>PartialEq</a> for <a class='struct' href='../../../../trust_dns/rr/rdata/sig/struct.SIG.html' title='trust_dns::rr::rdata::sig::SIG'>SIG</a></code></h3><div class='impl-items'><h4 id='method.eq' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../../../../trust_dns/rr/rdata/sig/struct.SIG.html' title='trust_dns::rr::rdata::sig::SIG'>SIG</a>) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<h4 id='method.ne' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../../../../trust_dns/rr/rdata/sig/struct.SIG.html' title='trust_dns::rr::rdata::sig::SIG'>SIG</a>) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html' title='core::fmt::Debug'>Debug</a> for <a class='struct' href='../../../../trust_dns/rr/rdata/sig/struct.SIG.html' title='trust_dns::rr::rdata::sig::SIG'>SIG</a></code></h3><div class='impl-items'><h4 id='method.fmt' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, __arg_0: &amp;mut <a class='struct' href='https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html' title='core::fmt::Formatter'>Formatter</a>) -&gt; <a class='type' href='https://doc.rust-lang.org/nightly/core/fmt/type.Result.html' title='core::fmt::Result'>Result</a></code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../../../";
        window.currentCrate = "trust_dns";
        window.playgroundUrl = "";
    </script>
    <script src="../../../../jquery.js"></script>
    <script src="../../../../main.js"></script>
    
    <script defer src="../../../../search-index.js"></script>
</body>
</html>