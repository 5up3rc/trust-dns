<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Client` struct in crate `trust_dns`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Client">

    <title>trust_dns::client::Client - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='../index.html'>trust_dns</a>::<wbr><a href='index.html'>client</a></p><script>window.sidebarCurrent = {name: 'Client', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../index.html'>trust_dns</a>::<wbr><a href='index.html'>client</a>::<wbr><a class='struct' href=''>Client</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-6224' class='srclink' href='../../src/trust_dns/src/client/client.rs.html#35-39' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Client&lt;C: <a class='trait' href='../../trust_dns/client/trait.ClientConnection.html' title='trust_dns::client::ClientConnection'>ClientConnection</a>&gt; {
    // some fields omitted
}</pre><div class='docblock'><p>The Client is abstracted over either trust_dns::tcp::TcpClientConnection or
trust_dns::udp::UdpClientConnection, usage of TCP or UDP is up to the user. Some DNS servers
disallow TCP in some cases, so if TCP double check if UDP works.</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl&lt;C: <a class='trait' href='../../trust_dns/client/trait.ClientConnection.html' title='trust_dns::client::ClientConnection'>ClientConnection</a>&gt; <a class='struct' href='../../trust_dns/client/struct.Client.html' title='trust_dns::client::Client'>Client</a>&lt;C&gt;</code></h3><div class='impl-items'><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>(client_connection: C) -&gt; <a class='struct' href='../../trust_dns/client/struct.Client.html' title='trust_dns::client::Client'>Client</a>&lt;C&gt;</code></h4>
<div class='docblock'><p>Creates a new DNS client with the specified connection type</p>

<h1 id='arguments' class='section-header'><a href='#arguments'>Arguments</a></h1>
<ul>
<li><code>client_connection</code> - the client_connection to use for all communication</li>
</ul>
</div><h4 id='method.with_trust_anchor' class='method'><code>fn <a href='#method.with_trust_anchor' class='fnname'>with_trust_anchor</a>(client_connection: C, trust_anchor: <a class='struct' href='../../trust_dns/rr/dnssec/struct.TrustAnchor.html' title='trust_dns::rr::dnssec::TrustAnchor'>TrustAnchor</a>) -&gt; <a class='struct' href='../../trust_dns/client/struct.Client.html' title='trust_dns::client::Client'>Client</a>&lt;C&gt;</code></h4>
<div class='docblock'><p>This variant allows for the trust_anchor to be replaced</p>

<h1 id='arguments-1' class='section-header'><a href='#arguments-1'>Arguments</a></h1>
<ul>
<li><code>client_connection</code> - the client_connection to use for all communication</li>
<li><code>trust_anchor</code> - the set of trusted DNSKEY public_keys, by default this only contains the
               root public_key.</li>
</ul>
</div><h4 id='method.secure_query' class='method'><code>fn <a href='#method.secure_query' class='fnname'>secure_query</a>(&amp;self, query_name: &amp;<a class='struct' href='../../trust_dns/rr/domain/struct.Name.html' title='trust_dns::rr::domain::Name'>Name</a>, query_class: <a class='enum' href='../../trust_dns/rr/dns_class/enum.DNSClass.html' title='trust_dns::rr::dns_class::DNSClass'>DNSClass</a>, query_type: <a class='enum' href='../../trust_dns/rr/record_type/enum.RecordType.html' title='trust_dns::rr::record_type::RecordType'>RecordType</a>) -&gt; <a class='type' href='../../trust_dns/error/type.ClientResult.html' title='trust_dns::error::ClientResult'>ClientResult</a>&lt;<a class='struct' href='../../trust_dns/op/message/struct.Message.html' title='trust_dns::op::message::Message'>Message</a>&gt;</code></h4>
<div class='docblock'><p>DNSSec validating query, this will return an error if the requested records can not be
 validated against the trust_anchor.</p>

<p>When the resolver receives an answer via the normal DNS lookup process, it then checks to
 make sure that the answer is correct. Then starts
 with verifying the DS and DNSKEY records at the DNS root. Then use the DS
 records for the top level domain found at the root, e.g. &#39;com&#39;, to verify the DNSKEY
 records in the &#39;com&#39; zone. From there see if there is a DS record for the
 subdomain, e.g. &#39;example.com&#39;, in the &#39;com&#39; zone, and if there is use the
 DS record to verify a DNSKEY record found in the &#39;example.com&#39; zone. Finally,
 verify the RRSIG record found in the answer for the rrset, e.g. &#39;<a href="http://www.example.com">www.example.com</a>&#39;.</p>

<p><em>Note</em> As of now, this will not recurse on PTR or CNAME record responses, that is up to
       the caller.</p>

<h1 id='arguments-2' class='section-header'><a href='#arguments-2'>Arguments</a></h1>
<ul>
<li><code>query_name</code> - the label to lookup</li>
<li><code>query_class</code> - most likely this should always be DNSClass::IN</li>
<li><code>query_type</code> - record type to lookup</li>
</ul>
</div><h4 id='method.query' class='method'><code>fn <a href='#method.query' class='fnname'>query</a>(&amp;self, name: &amp;<a class='struct' href='../../trust_dns/rr/domain/struct.Name.html' title='trust_dns::rr::domain::Name'>Name</a>, query_class: <a class='enum' href='../../trust_dns/rr/dns_class/enum.DNSClass.html' title='trust_dns::rr::dns_class::DNSClass'>DNSClass</a>, query_type: <a class='enum' href='../../trust_dns/rr/record_type/enum.RecordType.html' title='trust_dns::rr::record_type::RecordType'>RecordType</a>) -&gt; <a class='type' href='../../trust_dns/error/type.ClientResult.html' title='trust_dns::error::ClientResult'>ClientResult</a>&lt;<a class='struct' href='../../trust_dns/op/message/struct.Message.html' title='trust_dns::op::message::Message'>Message</a>&gt;</code></h4>
<div class='docblock'><p>A <em>classic</em> DNS query, i.e. does not perform and DNSSec operations</p>

<p><em>Note</em> As of now, this will not recurse on PTR or CNAME record responses, that is up to
       the caller.</p>

<h1 id='arguments-3' class='section-header'><a href='#arguments-3'>Arguments</a></h1>
<ul>
<li><code>name</code> - the label to lookup</li>
<li><code>query_class</code> - most likely this should always be DNSClass::IN</li>
<li><code>query_type</code> - record type to lookup</li>
</ul>
</div><h4 id='method.create' class='method'><code>fn <a href='#method.create' class='fnname'>create</a>(&amp;self, record: <a class='struct' href='../../trust_dns/rr/resource/struct.Record.html' title='trust_dns::rr::resource::Record'>Record</a>, zone_origin: <a class='struct' href='../../trust_dns/rr/domain/struct.Name.html' title='trust_dns::rr::domain::Name'>Name</a>, signer: &amp;<a class='struct' href='../../trust_dns/rr/dnssec/struct.Signer.html' title='trust_dns::rr::dnssec::Signer'>Signer</a>) -&gt; <a class='type' href='../../trust_dns/error/type.ClientResult.html' title='trust_dns::error::ClientResult'>ClientResult</a>&lt;<a class='struct' href='../../trust_dns/op/message/struct.Message.html' title='trust_dns::op::message::Message'>Message</a>&gt;</code></h4>
<div class='docblock'><p>Sends a record to create on the server, this will fail if the record exists (atomicity
 depends on the server)</p>

<p><a href="https://tools.ietf.org/html/rfc2136">RFC 2136</a>, DNS Update, April 1997</p>

<pre><code class="language-text"> 2.4.3 - RRset Does Not Exist

  No RRs with a specified NAME and TYPE (in the zone and class denoted
  by the Zone Section) can exist.

  For this prerequisite, a requestor adds to the section a single RR
  whose NAME and TYPE are equal to that of the RRset whose nonexistence
  is required.  The RDLENGTH of this record is zero (0), and RDATA
  field is therefore empty.  CLASS must be specified as NONE in order
  to distinguish this condition from a valid RR whose RDLENGTH is
  naturally zero (0) (for example, the NULL RR).  TTL must be specified
  as zero (0).

2.5.1 - Add To An RRset

   RRs are added to the Update Section whose NAME, TYPE, TTL, RDLENGTH
   and RDATA are those being added, and CLASS is the same as the zone
   class.  Any duplicate RRs will be silently ignored by the primary
   master.
</code></pre>

<h1 id='arguments-4' class='section-header'><a href='#arguments-4'>Arguments</a></h1>
<ul>
<li><code>record</code> - the name of the record to create</li>
<li><code>zone_origin</code> - the zone name to update, i.e. SOA name</li>
<li><code>signer</code> - the signer, with private key, to use to sign the request</li>
</ul>

<p>The update must go to a zone authority (i.e. the server used in the ClientConnection)</p>
</div><h4 id='method.append' class='method'><code>fn <a href='#method.append' class='fnname'>append</a>(&amp;self, record: <a class='struct' href='../../trust_dns/rr/resource/struct.Record.html' title='trust_dns::rr::resource::Record'>Record</a>, zone_origin: <a class='struct' href='../../trust_dns/rr/domain/struct.Name.html' title='trust_dns::rr::domain::Name'>Name</a>, must_exist: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>, signer: &amp;<a class='struct' href='../../trust_dns/rr/dnssec/struct.Signer.html' title='trust_dns::rr::dnssec::Signer'>Signer</a>) -&gt; <a class='type' href='../../trust_dns/error/type.ClientResult.html' title='trust_dns::error::ClientResult'>ClientResult</a>&lt;<a class='struct' href='../../trust_dns/op/message/struct.Message.html' title='trust_dns::op::message::Message'>Message</a>&gt;</code></h4>
<div class='docblock'><p>Appends a record to an existing rrset, optionally require the rrset to exis (atomicity
 depends on the server)</p>

<p><a href="https://tools.ietf.org/html/rfc2136">RFC 2136</a>, DNS Update, April 1997</p>

<pre><code class="language-text">2.4.1 - RRset Exists (Value Independent)

  At least one RR with a specified NAME and TYPE (in the zone and class
  specified in the Zone Section) must exist.

  For this prerequisite, a requestor adds to the section a single RR
  whose NAME and TYPE are equal to that of the zone RRset whose
  existence is required.  RDLENGTH is zero and RDATA is therefore
  empty.  CLASS must be specified as ANY to differentiate this
  condition from that of an actual RR whose RDLENGTH is naturally zero
  (0) (e.g., NULL).  TTL is specified as zero (0).

2.5.1 - Add To An RRset

   RRs are added to the Update Section whose NAME, TYPE, TTL, RDLENGTH
   and RDATA are those being added, and CLASS is the same as the zone
   class.  Any duplicate RRs will be silently ignored by the primary
   master.
</code></pre>

<h1 id='arguments-5' class='section-header'><a href='#arguments-5'>Arguments</a></h1>
<ul>
<li><code>record</code> - the record to append to an RRSet</li>
<li><code>zone_origin</code> - the zone name to update, i.e. SOA name</li>
<li><code>must_exist</code> - if true, the request will fail if the record does not exist</li>
<li><code>signer</code> - the signer, with private key, to use to sign the request</li>
</ul>

<p>The update must go to a zone authority (i.e. the server used in the ClientConnection). If
the rrset does not exist and must_exist is false, then the RRSet will be created.</p>
</div><h4 id='method.compare_and_swap' class='method'><code>fn <a href='#method.compare_and_swap' class='fnname'>compare_and_swap</a>(&amp;self, current: <a class='struct' href='../../trust_dns/rr/resource/struct.Record.html' title='trust_dns::rr::resource::Record'>Record</a>, new: <a class='struct' href='../../trust_dns/rr/resource/struct.Record.html' title='trust_dns::rr::resource::Record'>Record</a>, zone_origin: <a class='struct' href='../../trust_dns/rr/domain/struct.Name.html' title='trust_dns::rr::domain::Name'>Name</a>, signer: &amp;<a class='struct' href='../../trust_dns/rr/dnssec/struct.Signer.html' title='trust_dns::rr::dnssec::Signer'>Signer</a>) -&gt; <a class='type' href='../../trust_dns/error/type.ClientResult.html' title='trust_dns::error::ClientResult'>ClientResult</a>&lt;<a class='struct' href='../../trust_dns/op/message/struct.Message.html' title='trust_dns::op::message::Message'>Message</a>&gt;</code></h4>
<div class='docblock'><p>Compares and if it matches, swaps it for the new value (atomicity depends on the server)</p>

<pre><code class="language-text"> 2.4.2 - RRset Exists (Value Dependent)

  A set of RRs with a specified NAME and TYPE exists and has the same
  members with the same RDATAs as the RRset specified here in this
  section.  While RRset ordering is undefined and therefore not
  significant to this comparison, the sets be identical in their
  extent.

  For this prerequisite, a requestor adds to the section an entire
  RRset whose preexistence is required.  NAME and TYPE are that of the
  RRset being denoted.  CLASS is that of the zone.  TTL must be
  specified as zero (0) and is ignored when comparing RRsets for
  identity.

 2.5.4 - Delete An RR From An RRset

  RRs to be deleted are added to the Update Section.  The NAME, TYPE,
  RDLENGTH and RDATA must match the RR being deleted.  TTL must be
  specified as zero (0) and will otherwise be ignored by the primary
  master.  CLASS must be specified as NONE to distinguish this from an
  RR addition.  If no such RRs exist, then this Update RR will be
  silently ignored by the primary master.

 2.5.1 - Add To An RRset

  RRs are added to the Update Section whose NAME, TYPE, TTL, RDLENGTH
  and RDATA are those being added, and CLASS is the same as the zone
  class.  Any duplicate RRs will be silently ignored by the primary
  master.
</code></pre>

<h1 id='arguements' class='section-header'><a href='#arguements'>Arguements</a></h1>
<ul>
<li><code>current</code> - the current current which must exist for the swap to complete</li>
<li><code>new</code> - the new record with which to replace the current record</li>
<li><code>zone_origin</code> - the zone name to update, i.e. SOA name</li>
<li><code>signer</code> - the signer, with private key, to use to sign the request</li>
</ul>

<p>The update must go to a zone authority (i.e. the server used in the ClientConnection).</p>
</div><h4 id='method.delete_by_rdata' class='method'><code>fn <a href='#method.delete_by_rdata' class='fnname'>delete_by_rdata</a>(&amp;self, record: <a class='struct' href='../../trust_dns/rr/resource/struct.Record.html' title='trust_dns::rr::resource::Record'>Record</a>, zone_origin: <a class='struct' href='../../trust_dns/rr/domain/struct.Name.html' title='trust_dns::rr::domain::Name'>Name</a>, signer: &amp;<a class='struct' href='../../trust_dns/rr/dnssec/struct.Signer.html' title='trust_dns::rr::dnssec::Signer'>Signer</a>) -&gt; <a class='type' href='../../trust_dns/error/type.ClientResult.html' title='trust_dns::error::ClientResult'>ClientResult</a>&lt;<a class='struct' href='../../trust_dns/op/message/struct.Message.html' title='trust_dns::op::message::Message'>Message</a>&gt;</code></h4>
<div class='docblock'><p>Deletes a record (by rdata) from an rrset, optionally require the rrset to exist.</p>

<p><a href="https://tools.ietf.org/html/rfc2136">RFC 2136</a>, DNS Update, April 1997</p>

<pre><code class="language-text">2.4.1 - RRset Exists (Value Independent)

  At least one RR with a specified NAME and TYPE (in the zone and class
  specified in the Zone Section) must exist.

  For this prerequisite, a requestor adds to the section a single RR
  whose NAME and TYPE are equal to that of the zone RRset whose
  existence is required.  RDLENGTH is zero and RDATA is therefore
  empty.  CLASS must be specified as ANY to differentiate this
  condition from that of an actual RR whose RDLENGTH is naturally zero
  (0) (e.g., NULL).  TTL is specified as zero (0).

2.5.4 - Delete An RR From An RRset

  RRs to be deleted are added to the Update Section.  The NAME, TYPE,
  RDLENGTH and RDATA must match the RR being deleted.  TTL must be
  specified as zero (0) and will otherwise be ignored by the primary
  master.  CLASS must be specified as NONE to distinguish this from an
  RR addition.  If no such RRs exist, then this Update RR will be
  silently ignored by the primary master.
</code></pre>

<h1 id='arguments-6' class='section-header'><a href='#arguments-6'>Arguments</a></h1>
<ul>
<li><code>record</code> - the record to delete from a RRSet, the name, type and rdata must match the
         record to delete</li>
<li><code>zone_origin</code> - the zone name to update, i.e. SOA name</li>
<li><code>signer</code> - the signer, with private key, to use to sign the request</li>
</ul>

<p>The update must go to a zone authority (i.e. the server used in the ClientConnection). If
the rrset does not exist and must_exist is false, then the RRSet will be deleted.</p>
</div><h4 id='method.delete_rrset' class='method'><code>fn <a href='#method.delete_rrset' class='fnname'>delete_rrset</a>(&amp;self, record: <a class='struct' href='../../trust_dns/rr/resource/struct.Record.html' title='trust_dns::rr::resource::Record'>Record</a>, zone_origin: <a class='struct' href='../../trust_dns/rr/domain/struct.Name.html' title='trust_dns::rr::domain::Name'>Name</a>, signer: &amp;<a class='struct' href='../../trust_dns/rr/dnssec/struct.Signer.html' title='trust_dns::rr::dnssec::Signer'>Signer</a>) -&gt; <a class='type' href='../../trust_dns/error/type.ClientResult.html' title='trust_dns::error::ClientResult'>ClientResult</a>&lt;<a class='struct' href='../../trust_dns/op/message/struct.Message.html' title='trust_dns::op::message::Message'>Message</a>&gt;</code></h4>
<div class='docblock'><p>Deletes an entire rrset, optionally require the rrset to exist.</p>

<p><a href="https://tools.ietf.org/html/rfc2136">RFC 2136</a>, DNS Update, April 1997</p>

<pre><code class="language-text">2.4.1 - RRset Exists (Value Independent)

  At least one RR with a specified NAME and TYPE (in the zone and class
  specified in the Zone Section) must exist.

  For this prerequisite, a requestor adds to the section a single RR
  whose NAME and TYPE are equal to that of the zone RRset whose
  existence is required.  RDLENGTH is zero and RDATA is therefore
  empty.  CLASS must be specified as ANY to differentiate this
  condition from that of an actual RR whose RDLENGTH is naturally zero
  (0) (e.g., NULL).  TTL is specified as zero (0).

2.5.2 - Delete An RRset

  One RR is added to the Update Section whose NAME and TYPE are those
  of the RRset to be deleted.  TTL must be specified as zero (0) and is
  otherwise not used by the primary master.  CLASS must be specified as
  ANY.  RDLENGTH must be zero (0) and RDATA must therefore be empty.
  If no such RRset exists, then this Update RR will be silently ignored
  by the primary master.
</code></pre>

<h1 id='arguments-7' class='section-header'><a href='#arguments-7'>Arguments</a></h1>
<ul>
<li><code>record</code> - the record to delete from a RRSet, the name, and type must match the
         record set to delete</li>
<li><code>zone_origin</code> - the zone name to update, i.e. SOA name</li>
<li><code>signer</code> - the signer, with private key, to use to sign the request</li>
</ul>

<p>The update must go to a zone authority (i.e. the server used in the ClientConnection). If
the rrset does not exist and must_exist is false, then the RRSet will be deleted.</p>
</div><h4 id='method.delete_all' class='method'><code>fn <a href='#method.delete_all' class='fnname'>delete_all</a>(&amp;self, name_of_records: <a class='struct' href='../../trust_dns/rr/domain/struct.Name.html' title='trust_dns::rr::domain::Name'>Name</a>, zone_origin: <a class='struct' href='../../trust_dns/rr/domain/struct.Name.html' title='trust_dns::rr::domain::Name'>Name</a>, dns_class: <a class='enum' href='../../trust_dns/rr/dns_class/enum.DNSClass.html' title='trust_dns::rr::dns_class::DNSClass'>DNSClass</a>, signer: &amp;<a class='struct' href='../../trust_dns/rr/dnssec/struct.Signer.html' title='trust_dns::rr::dnssec::Signer'>Signer</a>) -&gt; <a class='type' href='../../trust_dns/error/type.ClientResult.html' title='trust_dns::error::ClientResult'>ClientResult</a>&lt;<a class='struct' href='../../trust_dns/op/message/struct.Message.html' title='trust_dns::op::message::Message'>Message</a>&gt;</code></h4>
<div class='docblock'><p>Deletes all records at the specified name</p>

<p><a href="https://tools.ietf.org/html/rfc2136">RFC 2136</a>, DNS Update, April 1997</p>

<pre><code class="language-text">2.5.3 - Delete All RRsets From A Name

  One RR is added to the Update Section whose NAME is that of the name
  to be cleansed of RRsets.  TYPE must be specified as ANY.  TTL must
  be specified as zero (0) and is otherwise not used by the primary
  master.  CLASS must be specified as ANY.  RDLENGTH must be zero (0)
  and RDATA must therefore be empty.  If no such RRsets exist, then
  this Update RR will be silently ignored by the primary master.
</code></pre>

<h1 id='arguments-8' class='section-header'><a href='#arguments-8'>Arguments</a></h1>
<ul>
<li><code>name_of_records</code> - the name of all the record sets to delete</li>
<li><code>zone_origin</code> - the zone name to update, i.e. SOA name</li>
<li><code>dns_class</code> - the class of the SOA</li>
<li><code>signer</code> - the signer, with private key, to use to sign the request</li>
</ul>

<p>The update must go to a zone authority (i.e. the server used in the ClientConnection). This
operation attempts to delete all resource record sets the the specified name reguardless of
the record type.</p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "trust_dns";
        window.playgroundUrl = "";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    
    <script defer src="../../search-index.js"></script>
</body>
</html>